<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic 3D Castle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Realistic 3D Castle</strong><br>
        üè∞ Exterior & Interior Views<br>
        üé® Realistic Textures & Lighting<br>
        üñ±Ô∏è Mouse: Rotate | Scroll: Zoom
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87CEEB);
        document.body.appendChild(renderer.domElement);

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();

        // Create procedural textures
        function createStoneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Base stone color
            ctx.fillStyle = '#8B7D6B';
            ctx.fillRect(0, 0, 256, 256);
            
            // Add stone patterns
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${90 + Math.random() * 40}, ${70 + Math.random() * 30}, ${0.3 + Math.random() * 0.4})`;
                ctx.fillRect(Math.random() * 256, Math.random() * 256, 20 + Math.random() * 40, 20 + Math.random() * 40);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, 256, 256);
            
            // Wood grain
            for (let i = 0; i < 15; i++) {
                ctx.strokeStyle = `rgba(${60 + Math.random() * 30}, ${30 + Math.random() * 20}, ${10 + Math.random() * 15}, 0.5)`;
                ctx.lineWidth = 2 + Math.random() * 3;
                ctx.beginPath();
                ctx.moveTo(0, i * 17);
                ctx.lineTo(256, i * 17 + Math.sin(i) * 5);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        const stoneMaterial = new THREE.MeshLambertMaterial({ map: createStoneTexture() });
        const woodMaterial = new THREE.MeshLambertMaterial({ map: createWoodTexture() });
        const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });

        // Castle group
        const castle = new THREE.Group();

        // Main keep (central tower)
        const keepGeometry = new THREE.CylinderGeometry(8, 10, 25, 8);
        const keep = new THREE.Mesh(keepGeometry, stoneMaterial);
        keep.position.y = 12.5;
        keep.castShadow = true;
        castle.add(keep);

        // Keep roof
        const keepRoofGeometry = new THREE.ConeGeometry(10, 8, 8);
        const keepRoof = new THREE.Mesh(keepRoofGeometry, roofMaterial);
        keepRoof.position.y = 29;
        castle.add(keepRoof);

        // Corner towers
        const positions = [
            { x: 20, z: 20 }, { x: -20, z: 20 },
            { x: 20, z: -20 }, { x: -20, z: -20 }
        ];

        positions.forEach(pos => {
            const towerGeometry = new THREE.CylinderGeometry(4, 5, 18, 6);
            const tower = new THREE.Mesh(towerGeometry, stoneMaterial);
            tower.position.set(pos.x, 9, pos.z);
            tower.castShadow = true;
            castle.add(tower);

            const towerRoofGeometry = new THREE.ConeGeometry(5.5, 6, 6);
            const towerRoof = new THREE.Mesh(towerRoofGeometry, roofMaterial);
            towerRoof.position.set(pos.x, 21, pos.z);
            castle.add(towerRoof);
        });

        // Castle walls
        const wallPositions = [
            { x: 0, z: 20, w: 40, h: 12, d: 2 },
            { x: 0, z: -20, w: 40, h: 12, d: 2 },
            { x: 20, z: 0, w: 2, h: 12, d: 40 },
            { x: -20, z: 0, w: 2, h: 12, d: 40 }
        ];

        wallPositions.forEach(wall => {
            const wallGeometry = new THREE.BoxGeometry(wall.w, wall.h, wall.d);
            const wallMesh = new THREE.Mesh(wallGeometry, stoneMaterial);
            wallMesh.position.set(wall.x, wall.h/2, wall.z);
            wallMesh.castShadow = true;
            castle.add(wallMesh);
        });

        // Main gate
        const gateGeometry = new THREE.BoxGeometry(6, 8, 3);
        const gate = new THREE.Mesh(gateGeometry, woodMaterial);
        gate.position.set(0, 4, -20);
        castle.add(gate);

        // Interior elements (visible when camera moves inside)
        const interiorGroup = new THREE.Group();
        
        // Interior floor
        const floorGeometry = new THREE.PlaneGeometry(35, 35);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0.1;
        interiorGroup.add(floor);

        // Interior pillars
        for (let i = -10; i <= 10; i += 20) {
            for (let j = -10; j <= 10; j += 20) {
                if (i === 0 && j === 0) continue; // Skip center
                const pillarGeometry = new THREE.CylinderGeometry(1, 1.2, 15, 8);
                const pillar = new THREE.Mesh(pillarGeometry, stoneMaterial);
                pillar.position.set(i, 7.5, j);
                interiorGroup.add(pillar);
            }
        }

        // Throne
        const throneBase = new THREE.BoxGeometry(3, 1, 2);
        const throneBack = new THREE.BoxGeometry(3, 4, 0.5);
        const throne1 = new THREE.Mesh(throneBase, stoneMaterial);
        const throne2 = new THREE.Mesh(throneBack, stoneMaterial);
        throne1.position.set(0, 0.5, 8);
        throne2.position.set(0, 2.5, 8.75);
        interiorGroup.add(throne1);
        interiorGroup.add(throne2);

        castle.add(interiorGroup);
        scene.add(castle);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x567d46 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Camera setup
        camera.position.set(30, 20, 30);
        camera.lookAt(0, 10, 0);

        // Mouse controls
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let cameraRadius = 50;
        let cameraTheta = 0;
        let cameraPhi = 0.5;

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                cameraTheta += deltaX * 0.01;
                cameraPhi += deltaY * 0.01;
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        document.addEventListener('wheel', (event) => {
            cameraRadius += event.deltaY * 0.05;
            cameraRadius = Math.max(15, Math.min(100, cameraRadius));
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update camera position
            camera.position.x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.y = cameraRadius * Math.cos(cameraPhi);
            camera.position.z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            camera.lookAt(0, 10, 0);
            
            // Rotate castle slowly
            castle.rotation.y += 0.002;
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
