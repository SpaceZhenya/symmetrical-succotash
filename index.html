<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Castle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Setup scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Castle materials
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
        const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });

        // Create main castle walls
        const frontWall = new THREE.Mesh(new THREE.BoxGeometry(10, 4, 0.5), wallMaterial);
        frontWall.position.set(0, 2, -5);
        frontWall.castShadow = true;
        scene.add(frontWall);

        const backWall = new THREE.Mesh(new THREE.BoxGeometry(10, 4, 0.5), wallMaterial);
        backWall.position.set(0, 2, 5);
        backWall.castShadow = true;
        scene.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 10), wallMaterial);
        leftWall.position.set(-5, 2, 0);
        leftWall.castShadow = true;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 10), wallMaterial);
        rightWall.position.set(5, 2, 0);
        rightWall.castShadow = true;
        scene.add(rightWall);

        // Create four corner towers
        function createTower(x, z) {
            const towerGroup = new THREE.Group();
            
            // Tower base
            const towerBase = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 6, 8), wallMaterial);
            towerBase.position.y = 3;
            towerBase.castShadow = true;
            towerGroup.add(towerBase);
            
            // Tower roof
            const towerRoof = new THREE.Mesh(new THREE.ConeGeometry(1.2, 2, 8), roofMaterial);
            towerRoof.position.y = 7;
            towerRoof.castShadow = true;
            towerGroup.add(towerRoof);
            
            towerGroup.position.set(x, 0, z);
            return towerGroup;
        }

        // Add four corner towers
        scene.add(createTower(-5, -5));
        scene.add(createTower(5, -5));
        scene.add(createTower(-5, 5));
        scene.add(createTower(5, 5));

        // Create gate entrance
        const gateGeometry = new THREE.BoxGeometry(2, 2.5, 0.3);
        const gateMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
        const gate = new THREE.Mesh(gateGeometry, gateMaterial);
        gate.position.set(0, 1.25, -4.9);
        scene.add(gate);

        // Add battlements on walls
        function createBattlement(x, y, z, rotation) {
            const battlement = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), wallMaterial);
            battlement.position.set(x, y, z);
            battlement.rotation.y = rotation;
            battlement.castShadow = true;
            return battlement;
        }

        // Front wall battlements
        for (let i = -4; i <= 4; i += 1) {
            if (Math.abs(i) > 1) { // Skip middle for gate
                scene.add(createBattlement(i, 4.5, -5, 0));
            }
        }

        // Back wall battlements
        for (let i = -4; i <= 4; i += 1) {
            scene.add(createBattlement(i, 4.5, 5, 0));
        }

        // Position camera
        camera.position.set(12, 8, 12);
        camera.lookAt(0, 2, 0);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Slowly rotate the camera around the castle
            const time = Date.now() * 0.0002;
            camera.position.x = Math.cos(time) * 15;
            camera.position.z = Math.sin(time) * 15;
            camera.lookAt(0, 2, 0);
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>
