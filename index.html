<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Castle</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="info">
    3D Castle Scene<br>
    Mouse: Rotate | Scroll: Zoom
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    // Removed fog to improve visibility
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(50, 40, 50);
    camera.lookAt(0, 0, 0);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    // Lighting - INCREASED BRIGHTNESS
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.far = 200;
    scene.add(directionalLight);
    // Additional point light for better illumination
    const pointLight = new THREE.PointLight(0xffffff, 0.8, 150);
    pointLight.position.set(0, 50, 0);
    scene.add(pointLight);
    // Ground
    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x3CB371 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    // Castle group
    const castle = new THREE.Group();
    // Function to create tower
    function createTower(x, z, height) {
      const towerGroup = new THREE.Group();
      
      // Tower body - LIGHTER COLOR
      const bodyGeometry = new THREE.CylinderGeometry(3, 3, height, 16);
      const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0xB8B8B8 });
      const body = new THREE.Mesh(bodyGeometry, stoneMaterial);
      body.position.y = height / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      towerGroup.add(body);
      // Tower roof
      const roofGeometry = new THREE.ConeGeometry(4, 6, 16);
      const roofMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.y = height + 3;
      roof.castShadow = true;
      towerGroup.add(roof);
      // Windows
      const windowGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.5);
      const windowMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, emissive: 0xFFAA00, emissiveIntensity: 0.3 });
      for (let i = 0; i < 4; i++) {
        const angle = (Math.PI / 2) * i;
        const window = new THREE.Mesh(windowGeometry, windowMaterial);
        window.position.x = Math.cos(angle) * 3.2;
        window.position.y = height * 0.6;
        window.position.z = Math.sin(angle) * 3.2;
        towerGroup.add(window);
      }
      towerGroup.position.set(x, 0, z);
      return towerGroup;
    }
    // Function to create wall
    function createWall(x, z, width, height, rotation) {
      const wallGeometry = new THREE.BoxGeometry(width, height, 2);
      const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0xB8B8B8 });
      const wall = new THREE.Mesh(wallGeometry, stoneMaterial);
      wall.position.set(x, height / 2, z);
      wall.rotation.y = rotation;
      wall.castShadow = true;
      wall.receiveShadow = true;
      return wall;
    }
    // Create castle structure
    const towerHeight = 20;
    
    // Four corner towers
    castle.add(createTower(-15, -15, towerHeight));
    castle.add(createTower(15, -15, towerHeight));
    castle.add(createTower(-15, 15, towerHeight));
    castle.add(createTower(15, 15, towerHeight));
    // Walls connecting towers
    castle.add(createWall(0, -15, 24, 12, 0));
    castle.add(createWall(0, 15, 24, 12, 0));
    castle.add(createWall(-15, 0, 24, 12, Math.PI / 2));
    castle.add(createWall(15, 0, 24, 12, Math.PI / 2));
    // Central keep - LIGHTER COLOR
    const keepGeometry = new THREE.BoxGeometry(12, 25, 12);
    const keepMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9 });
    const keep = new THREE.Mesh(keepGeometry, keepMaterial);
    keep.position.y = 12.5;
    keep.castShadow = true;
    keep.receiveShadow = true;
    castle.add(keep);
    // Keep roof
    const keepRoofGeometry = new THREE.ConeGeometry(8, 8, 4);
    const keepRoofMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D });
    const keepRoof = new THREE.Mesh(keepRoofGeometry, keepRoofMaterial);
    keepRoof.position.y = 29;
    keepRoof.castShadow = true;
    castle.add(keepRoof);
    // Gate
    const gateGeometry = new THREE.BoxGeometry(6, 8, 0.5);
    const gateMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const gate = new THREE.Mesh(gateGeometry, gateMaterial);
    gate.position.set(0, 4, -15.5);
    castle.add(gate);
    // Add battlements
    const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0xB8B8B8 });
    for (let i = -15; i <= 15; i += 3) {
      const battlement = new THREE.BoxGeometry(2, 2, 2);
      const battlementMesh = new THREE.Mesh(battlement, stoneMaterial);
      battlementMesh.position.set(i, 13, -15);
      battlementMesh.castShadow = true;
      castle.add(battlementMesh);
      
      const battlementMesh2 = new THREE.Mesh(battlement, stoneMaterial);
      battlementMesh2.position.set(i, 13, 15);
      battlementMesh2.castShadow = true;
      castle.add(battlementMesh2);
    }
    scene.add(castle);
    // Add some trees
    function createTree(x, z) {
      const treeGroup = new THREE.Group();
      
      const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 6, 8);
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 3;
      trunk.castShadow = true;
      treeGroup.add(trunk);
      const leavesGeometry = new THREE.ConeGeometry(3, 8, 8);
      const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
      const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
      leaves.position.y = 9;
      leaves.castShadow = true;
      treeGroup.add(leaves);
      treeGroup.position.set(x, 0, z);
      return treeGroup;
    }
    // Add trees around castle
    scene.add(createTree(-35, -35));
    scene.add(createTree(-35, 35));
    scene.add(createTree(35, -35));
    scene.add(createTree(35, 35));
    scene.add(createTree(-40, 0));
    scene.add(createTree(40, 0));
    // Mouse controls
    let mouseX = 0;
    let mouseY = 0;
    let targetRotationX = 0;
    let targetRotationY = 0;
    document.addEventListener('mousemove', (event) => {
      mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    });
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      // Smooth camera rotation based on mouse
      targetRotationY = mouseX * 0.5;
      targetRotationX = mouseY * 0.3;
      
      camera.position.x = 50 * Math.cos(targetRotationY) * Math.cos(targetRotationX);
      camera.position.y = 40 + 20 * targetRotationX;
      camera.position.z = 50 * Math.sin(targetRotationY) * Math.cos(targetRotationX);
      camera.lookAt(0, 10, 0);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
